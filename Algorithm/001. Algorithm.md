# 001. Algorithm

> restart

### 다시 정리하는 이유

SW 공부를 해나갈수록, 체계화되지 않은 지식이 걸림돌이 된다는 것을 많이 느끼게 되었다. 특히 알고리즘의 경우 앞부분의 간단한 개념만 사용하는 문제만 풀이가 가능하고, 뒷 문제들은 하나도 풀어내지 못하는 문제들이 많았다.

또한 새로운 언어, 프레임워크, 개발 방법론을 배워나가기에 앞서 확실하게 알고리즘에 대한 개념을 다져둔다면 추후 새로운 내용을 배워나갈 때에도 큰 도움이 될 것이라고 생각한다. 

## SW 문제 해결

### 문제 해결 과정

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의 한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 문제 해결 전략

직관 + 체계적인 접근

체계적인 접근을 위한 질문?

1. 비슷한 문제를 풀어본 적이 있었나?
2. 단순한 방법에서 시작할 수 있을까?
3. 문제를 단순화 할 수 있을까?
4. 그림으로 그려 볼 수 있을까?
5. 수식으로 표현할 수 있을까?
6. 문제를 분해할 수 있을까?
7. 뒤에서부터 생각해서 문제를 풀 수 있을까?
8. 특정 형태의 답만을 고려할 수 있을까?



## 복잡도 분석

### 알고리즘의 효율

**공간적 효율성** : 연산량 대비 얼마나 적은 메모리 공간을 요하는가?

**시간적 효율성** : 연산량 대비 얼마나 적은 시간을 요하는가?

효율성을 뒤집어 표현하면 복잡도 (Complexity)가 된다.

여기서 시간적 복잡도는 하드웨어 환경 / 소프트웨어 환경 (프로그램 언어의 종류, 운영체제, 컴파일러 종류) 등의 차이에 따라서 달라지기 때문에 분석이 어렵다.

### 복잡도의 점근적 표기

복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다.

이를 단순한 함수로 표현하기 위해 점근적 표기 (Asymptotic Notation)를 사용한다.

입력 크기 n 이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해서 사용하는 표기법이다.

- O (Big-Oh) 표기
- Ω (Big-Omega) 표기
- Θ (Big-Theta) 표기

### O (Big-Oh) 표기

복잡도의 점근적 상한을 나타낸다.

복잡도가 `f(n) = 2n² - 7n + 4` 이라면, `f(n)`의 O - 표기는 `O(n²)`이다.

먼저 `f(n)`의 단순화된 표현은 n²이다.

단순화된 함수 n²에 임의의 상수 c를 곱한 cn²이 n이 증가함에 따라 f(n)의 상한이 된다. (단, c > 0)

점근적 상한이라는 의미는 n₀보다 큰 모든 n에 대해서 항상 f(n) 보다 크다는 것

### Ω (Big-Omega) 표기

복잡도의 점근적 하한을 나타낸다.

복잡도가 `f(n) = 2n² - 7n + 4` 이라면, `f(n)`의 Ω - 표기는 `Ω(n²)`이다.

`f(n) = Ω(n²)` : "n이 증가함에 따라 2n² - 7n + 4 이 cn² 보다 작을 수 없다." 의 의미. 이 때 상수 c = 1

"최소한 이만한 시간은 걸린다 의 의미"

### Θ (Big-Theta) 표기

O 표기와 Ω 표기가 같은 경우에 사용한다.

`f(n) = Θ(n²)` : "n²과 동일한 증가율을 가진다"의 의미

### 왜 효율적인 알고리즘이 필요한가?

10억개의 숫자를 정렬하는데 PC에서 `O(n²)`알고리즘은 300여 년이 걸리는 반면에 `O(nlogn)`알고리즘은 5분만에 정렬한다. 이렇듯 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있다.값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 경제적이다.