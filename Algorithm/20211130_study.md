# 20211130_study

> 2021.11.30 스터디 결과 : 2/5 풀이
>
> 23일 못푼 문제들 하나도 못풀어봤다. 일정들이 끝나고 나면 밀린 문제들을 차근차근 풀어봐야겠다.

## BJ10158 개미

> 링크 : https://www.acmicpc.net/problem/10158
>
> 분류 : 수학, 사칙연산, 애드 혹

```python
# BJ10158. 개미
# 반사 되어 움직이므로, 각 면마다 격자공간을 대칭해두면 일직선의 개미 경로가 나온다.
# 일직선으로 움직였다고 보고 나온 좌표를
# 가로 세로 길이로 나누었을 때, 몫이 짝수이면 원래상태
# 몫이 홀수이면 대칭상태라고 생각할 수 있고
# 나눈 나머지 값을 통해서 좌표를 특정할 수 있다.
# 예를들면 그림에서 6*4 격자 상에 4,1 에서 출발한 개미는
# 8시간 후 일직선 좌표로 12, 9이다
# 각각 나누었을때 2, 0 // 2, 1으로 몫이 둘다 짝수니 0,1 이된다

w, h = map(int, input().split())
p, q = map(int, input().split())
t = int(input())
straight_p = p + t
straight_q = q + t
x = 0
y = 0

if (straight_p//w)%2:
    x = w - straight_p%w
else:
    x = straight_p%w

if (straight_q//h)%2:
    y = h - straight_q%h
else:
    y = straight_q%h

print(x, y)
```

반사되어 나가는 경로들을 전부 대칭으로 놓는다면 경로를 일직선으로 만들 수 있다.

따라서 일직선 경로를 구한다음 반사되는 조건을 생각한다면 최종 도착지점을 찾을 수 있다.

일직선 경로를 가로나 세로 길이로 나눈 몫과 나머지를 활용해야 하는데, 몫의 경우 짝수일 때는 원본과 같은 방향의 격자를, 홀수일 때는 반대 방향의 격자를 갖는다는 것을 생각하면 간단하게 풀린다.



## BJ7795 먹을 것인가 먹힐 것인가

> 링크 : https://www.acmicpc.net/problem/7795
>
> 분류 : 정렬, 이분 탐색, 두 포인터

```python
# BJ7795. 먹을 것인가 먹힐 것인가
# 투포인터
# 두 그룹 모두 정렬 후, A의 인덱스와 B의 인덱스를 순차적으로 탐색
# A고정 B 증가 / 같거나 B가 크면 A 증가

test_case = int(input())

for t in range(test_case):
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    A.sort() # 각각 정렬
    B.sort()

    x, y = 0, 0 # x : A인덱스 y : B 인덱스
    answer = [0] * len(A)
    while x < len(A):
        if A[x] <= B[y]:
            answer[x] = y
            x += 1
        else:
            if 0 <= y < len(B)-1:
                y += 1
            else:
                answer[x] = y+1

                x += 1
    print(sum(answer))
```

A 생명체 기준, 가능한 쌍의 개수를 담은 배열 answer를 만들었다. (answer[i]는 A[i]의 정보이다.)

두 그룹 모두 낮은 숫자부터 정렬하여 각각의 인덱스를 키워가며 비교하는 투 포인터알고리즘을 사용하였다.



## BJ2228 구간 나누기

> 링크 : https://www.acmicpc.net/problem/2228
>
> 분류 : DP

M개 구간으로 나눠서 가장 큰 합이 되게 만드는 DP문제

부분합으로 배열을 만들어서 수를 받아줬음

dp 초기화를 가장 작은 수로 초기화 시킴

`dp[i][j]` : i 번째 숫자까지 j개의 구간으로 했을 때 최대값

`dp[i][j] = max (~ , dp[k][j-1] + part_sum[] - part_sum[])`

의 형태로 식을 세워서 풀이

다시 해볼 것



## BJ16947

사이클에 포함된 점이라는 정보를 미리 저장해놓는다. 얘네는 다 0

사이클에 포함되지 않는 애들은 

유니온 파인드 알고리즘으로 사이클에 포함 여부를 찾는다.

안되는 애들은 다 bfs돌려서 되는 애들 만날때까지 얼마나 걸리나



### 유니온 파인드

점 하나씩 없다고 생각하고, 포함된 루트는 다 무시하고 사이클이 생겼다면 얘는 사이클에 포함되지 않는 점이다.



원래 하려던대로 생각하면 하면 안된다. 갈래가 더 나뉜다.



## BJ1238

다익스트라 문제

X의 집에서 파티하는데 N명이 X 갔다가 집오는 모든 거리를 구해야 한다.



전형적인 다익스트라라서 특별히 설명할게 없다고 한다.

다익스트라 공부 + 문제 다시 보기!

