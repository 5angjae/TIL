# Ch11. CPU 스케쥴링

> 혼자공부하는 컴퓨터구조 + 운영체제

## 11-1. CPU 스케쥴링 개요

> 운영체제는 CPU를 어떻게 프로세스에 배분하는가

CPU 스케쥴링 : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

컴퓨터 성능과 직결되는 중요한 문제로 CPU를 적절하게 배분하지 못하면 무질서한 상태가 발생할 수 있다.

무질서한 상태 : 반드시 실행되어야 하는 프로세스 실행 X, 당장 급하지 않은 프로세스만 실행 등

### 프로세스 우선 순위

우선순위가 높은 프로세스에는 대표적으로 입출력 작업이 많은 프로세스가 있다.

프로세스는 실행 상태와 대기 상태를 반복하며 실행된다. 그런데 프로세스 종류맏 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있는데, 입출력 작업이 많은 프로세스를 **입출력 집중 프로세스 (I/O bound process)**, CPU 작업이 많은 프로세스를 **CPU 집중 프로세스 (CPU bound process)**라고 한다. 

입출력 집중 프로세스의 경우, 실행 상태보다는 입출력을 위한 대기상태에 많이 머무르게 되고, CPU 집중 프로세스의 경우 대기 상태보다는 실행 상태에 더 많이 머무르게 된다. 이렇게 두 프로세스의 CPU 사용량이 다른데 동일한 빈도로 CPU를 사용하는 것은 비합리적이다. 따라서 잠깐 실행하고 입출력 대기상태로 들어가는 입출력 집중 프로세스를 먼저 처리하고 다른 프로세스가 CPU를 사용할 수 있도록 해주는 것이 좋기 때문에, 입출력 작업이 많은 프로세스가 우선순위가 높게 처리된다.

이렇게 프로세스의 중요도에 맞게 CPU를 이용할 수 있도록 운영체제는 프로세스마다 우선순위를 부여한다. 이는 PCB에 명시하고 PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

### 스케쥴링 큐

PCB에 우선순위가 적혀있지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다. CPU 자원 뿐만 아니라 메모리 적재가 필요한 프로세스, 입출력장치 사용이 필요한 프로세스 등 다양한 문제에서도 마찬가지이다.

따라서 운영체제는 프로세스들에 줄을 서서 기다릴 것을 요구하는데, 이 줄 세우는 것을 스케쥴링 큐(scheduling queue)로 구현하고 관리한다.

```
참고) 큐는 자료구조 관점에서 봤을 때는 선입선출 구조이지만, 스케쥴링에서 이야기하는 큐는 반드시 선입선출 방식일 필요는 없다.
```

운영체제가 관리하는 대부분의 자원은 큐로 관리되는데, 대표적인 큐로는 준비 큐와 대기 큐가 있다.

준비 큐 (ready queue) : CPU를 이용하고 싶은 프로세스들이 서는 줄.

대기 큐 (waiting queue) : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄.

![](../../assets/OS_process_state_diagram.png)



### 선점형과 비선점형 스케쥴링

갑자기 다른 급한 프로세스가 CPU를 지금 당장 사용하길 요청한다면?

#### 선점형 스케쥴링 (preemptive scheduling)

CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케쥴링 방식.

어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케쥴링 방식.

타이머 인터럽트가 발생해서 다음 프로세스를 할당하는 방식도 선점형 스케쥴링의 일종이라 할 수 있다.

#### 비선점형 스케쥴링 (non-preemptive scheduling)

하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케쥴링 방식.

하나의 프로세스가 자원을 독점할 수 있다.

### 비교

대부분의 운영체제는 선점형 스케쥴링 방식을 사용.

선점형 스케쥴링 장점 : 더 급한 프로세스가 언제든 끼어들어 사용할 수 있어, 자원 독점을 막고 프로세스들에 골고루 자원을 분배할 수 있다.

선점형 스케쥴링 단점 : 문맥 교환과정에서 오버헤드가 발생할 수 있다.

비선점형 스케쥴링 장점 : 문맥교환에서 발생하는 오버헤드가 적다.

비선점형 스케쥴링 단점 : 모든 프로세스가 골고루 자원을 사용할 수 없고, 당장 사용해야하는 상황에서도 무작정 기다리는 수 밖에 없다.

**오버헤드** : 프로그램의 실행흐름에서 나타나는 현상 중 하나로, 프로그램으 실행 흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때 추가적으로 시간, 메모리, 자원이 사용되는 현상. (특정 기능을 수행하는데 드는 간접적인 시간, 메모리 등 자원)



## 11-2. CPU 스케쥴링 알고리즘

CPU 스케쥴링 알고리즘의 종류는 매우 다양하고, 운영체제 저마다 서로 다른 스케쥴링 알고리즘을 사용하고 있다. 중요한 것은 각 스케쥴링 알고리즘에서 사용된 '아이디어'이지 '용어'가 아니다. 따라서 각 알고리즘들의 작동 방식과 장단점을 이해하는데만 집중.

### 스케쥴링 알고리즘의 종류

#### 선입 선처리 스케쥴링

FCFS 스케쥴링 (First Come First Served)

단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케쥴링 방식

호위 효과(convoy effect) : 프로세스가 자신이 실행하는데 필요한 시간보다 훨씬 더 긴 시간을 기다려야 하는 현상.

#### 최단 작업 우선 스케쥴링

SJF 스케쥴링 (Shortest Job First Scheduling)

CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행.

기본적으로 비선점형으로 분류되지만, 선점형으로 구현될 수 있고 이 선점형 최단 작업 우선 스케쥴링이 최소 잔여 시간 우선스케쥴링이다.

#### 라운드 로빈 스케쥴링

선입 선처리 스케쥴링에 타임 슬라이스 개념이 더해진 방식. 

타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 위미.

정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케쥴링.

라운드 로빈 스케쥴링에서는 타임 슬라이스 크기가 매우 중요하다. 크기가 지나치게 크면 사실 상 선입 선처리 스케쥴링과 다를바 없어 호위 효과가 생길 여지가 있고, 타임 슬라이스가 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는데 힘을 쓸 여지가 있다.

#### 최소 잔여 시간 우선 스케쥴링

SRT 스케쥴링 (Shortest Remaining Time Scheduling)

최단 작업 우선 스케쥴링 알고리즘과 라운드 로빈 알고리즘을 합친 스케쥴링 방식.

정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.

#### 우선순위 스케쥴링

프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케쥴링 알고리즘

**근본적인 문제** :우선순위가 낮은 프로세스는 계속해서 연기될 수 있다. (기아(starvation) 현상)

**에이징(aging)** : 이를 방지하기 위한 기법. 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식.

#### 다단계 큐 스케쥴링

우선순위 스케쥴링의 발전된 형태.

multilevel queue scheduling

우선순위별로 준비 큐를 여러 개 사용하는 방식. 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리

큐를 여러개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다.

우선순위가 높은 큐에는 CPU 집중 프로세스를, 비교적 낮아도 되는 입출력 집중 프로세스는 다른 큐에, 백그라운드 프로세스는 또 다른 큐에, 우선순위가 비교적 낮아도 무방한 사용자와의 상호작용이 잦은 프로세스를 따로, 이런 식으로 삽입 가능하다.

또한 큐 별로 타임 슬라이스를 여러 개 지정할 수 있고, 큐마다 다른 스케쥴링 알고리즘을 사용할 수도 있다.

#### 다단계 피드백 큐 스케쥴링

multilevel feedback queue scheduling

다단계 큐 스케쥴링에서는 프로세스들이 큐 사이를 이동할 수 없다. 따라서 우선순위가 낮은 프로세스들은 계속 연기될 여지가 있고, 기아현상이 다시 발생할 수 있다. 이를 보완한 스케쥴링 알고리즘.

즉, 프로세스들이 큐 사이를 이동할 수 있다. 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간(타임 슬라이스) 동안 실행된다. 

그리고 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행되는 과정을 반복한다. 결국 CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아진다.

즉, CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU 를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝난다.

또한 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동 시키는 에이징 기법을 적용하여 기아 현상도 예방할 수 있다.

구현이 복잡하지만 가장 일반적인 CPU 스케쥴링 알고리즘.
