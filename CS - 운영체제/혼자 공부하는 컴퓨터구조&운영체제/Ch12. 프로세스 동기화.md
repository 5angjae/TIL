# Ch12. 프로세스 동기화

> 혼자공부하는 컴퓨터구조 + 운영체제

## 12-1. 동기화란

> 운영체제의 프로세스 관리 서비스 중 가장 중요한 두가지. 스케쥴링 / 동기화

동시에 실행되는 프로세스들은 서로 데이터를 주고 받거나, 같은 자원에 접근하는 등 서로 영향을 미치며 실행될 수 있다. 이런 작업들에 대해 수행시기를 맞춰 실행 순서와 자원의 일관성을 보장해야 하기 때문에 동기화가 되어야 한다.

### 동기화의 의미

#### `정보·통신 분야에서의 동기화란 작업들 사이의 수행시기를 맞추는 것`

프로세스 동기화는 프로세스들 사이의 수행 시기를 맞추는 것으로 크게 아래의 두가지 동기화를 말한다.

- 실행 순서 제어 : 프로세스를 올바른 순서대로 실행.
- 상호 배제 : 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기.

```
참고) 프로세스 뿐만 아니라 스레드도 동기화 대상이다. 정확히 말하면 실행의 흐름을 갖는 모든 것은 동기화의 대상이다. 다만, 전공서 표현에 따라 '프로세스 동기화'라고 보통 칭한다.
```

#### 실행 순서 제어를 위한 동기화

txt 파일에 저장된 정보를 읽는 프로세스를 Reader / 쓰는 프로세스를 Writer 라고 하고 두 프로세스가 동시에 실행 중이라 하자. 이 두 프로세스는 아무 순서로 실행되면 안된다.

Reader 프로세스는 Writer 프로세스 실행이 끝나야 실행할 수 있기 때문. (Reader 프로세스는 txt 파일에 값이 존재 한다는 특정 조건이 만족되어야만 실행을 이어나갈 수 있어서)

#### 상호 배제를 위한 동기화

상호 배제 (Mutual Exclusion) : 공유가 불가능한 자원의 동시사용을 피하기 위해 사용하는 알고리즘.

동기화가 제대로 이루어지지 않으면 자원에 동시에 접근하여 엉뚱한 결과가 나오는 경우가 생긴다.

### 생산자와 소비자 문제

상호 배제를 위한 동기화 예시.

'총합'이라는 데이터를 공유하고 있는 '생산자'와 '소비자'를 각각 100,000번씩 동시에 실행한다면 '총합'은 어떻게 변할 것인가? (생산자 => `총합 += 1` / 소비자 => `총합 -= 1`)

언듯 보기에는 변화 없을 것 같지만, 변화가 생기거나 실행 중 오류가 발생하기도 한다.

### 공유 자원과 임계 구역

**공유 자원** : 공동으로 사용하는 자원. 전역 변수가 될 수도 있고 파일이 될 수도 있고 입출력장치, 보조기억장치가 될 수도 있다.

**임계 구역** : 공유 자원에 접근하는 코드 중 동시에 실행하면 문제가 발생하는 코드 영역을 의미. 임계 구역에 진입한 프로세스가 있다면 다른 프로세스는 임계 구역 밖에서 기다려야 한다.

**레이스 컨디션 (race condition)** : 임계 구역은 두 개 이상의 프로세스가 동시에 실행되면 안되는 영역이지만, 잘못된 실행으로 인해 동시 다발적으로 여러 프로세스가 임계 구역의 코드를 실행하여 문제가 발생하는 경우

레이스 컨디션이 발생하면 생산자 소비자 문제처럼 데이터의 일관성이 깨지는 문제가 발생한다.

```java
// 생산자 소비자 문제
// 생산자 코드
총합++;
// 실행과정에 변환되는 저급 언어
r1 = 총합;
r1 = r1 + 1;
총합 = r1;
// 소비자 코드
총합--;
// 실행과정에 변환되는 저급 언어
r2 = 총합;
r2 = r2 - 1;
총합 = r2;
```

이 두 코드 중 한 코드가 아직 임계 구역에서 나오지 않았는데, 문맥교환이 이루어져 다음 프로세스가 임계구역에 들어가게 된다면 아래와 같은 문제가 발생한다.

| 프로세스A   | 프로세스B   | 현재 총합     | r1   | r2   |
| ----------- | ----------- | ------------- | ---- | ---- |
| r1 = 총합   |             | 10            | 10   |      |
| r1 = r1 + 1 |             | 10            | 11   |      |
| `문맥교환`  |             | 10            | 11   |      |
|             | r2 = 총합   | 10            | 11   | 10   |
|             | r2 = r2 - 1 | 10            | 11   | 9    |
|             | `문맥교환`  | 10            | 11   | 9    |
| 총합 = r1   |             | 11            | 11   | 9    |
| `문맥교환`  |             | 11            | 11   | 9    |
|             | 총합 = r2   | 9             | 11   | 9    |
|             |             | 최종 총합 = 9 |      |      |

상호 배제를 위한 동기화는 위와 같이 임계 구역에 동시에 두 개 이상의 프로세스가 들어가지 않도록 관리하는 것을 의미한다.

운영체제는 이런 임계 구역 문제를 아래 세가지 원칙 하에 해결한다. 즉, 상호 배제를 위한 동기화를 위해 아래 세가지 원칙이 반드시 지켜져야 한다.

**상호 배제(mutual exclusion)** : 한 프로세스가 임계 구역에서 작업 중이면 다른 프로세스가 임계 구역에 들어갈 수 없다.

**진행(progress)** : 임계 구역에 어떤 프로세스도 진입하지 않았다면, 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.

**유한 대기(bounded waiting)** : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다. (임계 구역에 들어오기 위해서 무한정 대기해서는 안된다.)



## 12-2. 동기화 기법

> 동기화를 위한 대표적인 도구. 뮤텍스 락. 세마포어. 모니터.

### 뮤텍스 락 (Mutex lock; MUTual EXclusion lock)

옷 가게에서 탈의실에 사람이 있는지 확인할 땐 자물쇠가 걸려있는지 확인하고 걸려있다면 기다리는데, 이런 자물쇠 기능을 코드로 구현한 것이 뮤텍스 락이다.

임계 구역에 진입하는 프로세스는 현재 임계 구역에 있음을 알리기 위해 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고, 다른 프로세스는 임계 구역이 잠겨 있다면 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있다.

뮤텍스 락의 매우 단순한 형태는 하나의 전역변수와 두 개의 함수로 구현 가능하다.

```
자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
임계 구역을 잠그는 역할 : acquire 함수
임계 구역의 잠금을 해제하는 역할 : release 함수
```

#### acquire 함수

프로세스가 임계 구역에 진입하기 전에 호출하는 함수. 만일 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지 (lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고, 임계 구역이 열려 있다면 임계 구역을 잠그는 (lock을 true로 바꾸는) 함수

```
acquire() {
    while(lock == true)
        ;
    lock = true;
}
```

#### release 함수

임계 구역에서의 작업이 끝나고 호출하는 함수. 현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는) 함수라고 보면 된다.

```
release() {
	lock = false;
}
```

#### 바쁜 대기 (busy wait)

acquire 함수에서 임계 구역이 잠겨 있을 경우, 반복적으로 lock을 확인하는 대기 방식.

```
참고)
C/C++, Python 등 일부 프로그래밍 언어에서는 사용자가 직접 acquire, release 함수를 구현하지 않도록 뮤텍스 락 기능을 제공.
```



### 세마포어 (semaphore)

뮤텍스 락의 경우, 1개의 공유 자원에 접근하는 프로세스를 상정한 방식.

세마포어는 여러개의 공유자원에 접근하는 프로세스를 상정한 방식(각 공유자원에는 하나의 프로세스만 진입 가능)

#### 이진 세마포어 (binary semaphore)

뮤텍스 락과 비슷한 개념. 세마포어 값으로 0과 1을 가져 뮤텍스 락과 마찬가지로 하나의 공유자원에 대한 프로세스를 처리해준다.

뮤텍스 락과 차이는

뮤텍스 락의 경우 락을 설정한 프로세스만이 락을 해제할 수 있는 반면, 이진 세마포어의 경우 락을 설정한 프로세스와 해제하는 프로세스가 다를 수 있다. (그러면 다른 프로세스가 락을 해제해버리면, 기존 임계 구역의 코드는 어떻게 됨?)



#### 카운팅 세마포 (counting semaphore)

카운팅 세마포도 뮤텍스 락과 마찬가지로 하나의 변수와 두 개의 함수로 단순하게 구현 가능하다.

```
전역 변수 S : 임계 구역에 진입할 수 있는 프로세스의 개수 (사용 가능한 공유 자원의 수)
wait 함수 : 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 함수
signal 함수 : 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 함수

함수의 이름은 일부 전공서에 따라
wait / signal
P / V (다익스트라의 모국어에 근거)
down / up (철도 신호기 근거)
라고 다르게 명명하기도 한다.
```

임계구역 진입 전후로 wait / signal 함수 호출

```
wait()
// 임계 구역
signal()
```

#### wait 함수

```
wait() {
    while(S <= 0) // 임계구역에 진입할 수 있는 프로세스 개수가 0 이하라면
        ;         // 사용할 수 있는 자원이 있는지 반복적으로 확인하고,
    S--;          // 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 진입
}
```

#### signal 함수

```
signal() {
	S++          // 임계 구역에서 작업을 마친 뒤 S 를 1 증가시킨다.
}
```

#### 바쁜 대기 상태를 해결하는 방법

사용 가능한 공유 자원이 없을 때 해당 프로세스를 대기 상태로 만들고 대기큐에 넣고, 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면 signal 함수는 대기 중인 프로세스를 대기 큥서 제거하고 준비상태로 바꾼다.

```java
wait() {
    S--;
    if (S < 0) {
        add this process to Queue; // 해당 프로세스 PCB를 대기 큐에 삽입한다.
        sleep();                   // 대기 상태로 접어든다.
    }
}
// 임계 구역
signal() {
    S++;
    if (S <= 0) {
        remove a process p from Queue; // 대기 큐에 있는 프로세스 p를 제거
        wakeup(p);                     // 프로세스 p를 대기 상태에서 준비상태로 만든다.
    }
}
```

#### 실행 순서 제어

상호 배제를 위한 동기화 뿐만 아니라 '실행 순서 제어를 위한 동기화'도 세마포어를 이용해서 원하는대로 제어 가능하다.

세마포어의 변수 S를 0으로 두고, 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙인다.

| P1           | P2           |
| ------------ | ------------ |
|              | `wait()`     |
| // 임계 구역 | // 임계 구역 |
| `signal()`   |              |

**P1 이 먼저 실행된다면**

P1이 먼저 임계 구역에 진입하는 것은 자명.

이후 signal()을 통해 S = 1이 되며, P2의 wait()를 통과하여 P2가 임계 구역에 진입 가능.

**P2가 먼저 실행된다면**

P2가 먼저 임계구역에 진입하면 S = 0 이므로 wait() 함수에서 대기 상태로 접어든다.

이후 P1이 먼저 임계 구역에 들어가게 되고 signal() 함수가 호출되며 대기 상태의 P2를 준비상태로 만든다.

### 모니터

매번 임계 구역 앞뒤로 wait 와 signal 함수를 명시하는 것은 번거로운 일이기 때문에, 더 사용자가 사용하기 편리한 도구로 등장한 것이 모니터이다.

공유자원과 공유자원에 접근하기 위한 인터페이스(통로)를 묶어 관리한다. 그리고 프로세스는 반드시 인터페이스를 통해서만 공유자원에 접근하도록 한다.

모니터는 공유 자원을 다루는 **인터페이스에 접근하기 위한 큐**(모니터에 진입하기 위한 큐)를 만들고, **모니터 안에 항상 하나의 프로세스만 들어오도록** 하여 상호 배제를 위한 동기화를 제공

또한 실행 순서 제어를 위한 동기화도 제공하는데, 특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 모니터는 조건 변수 (condition variable)를 사용한다.

```
wait
호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산.
모니터에 진입하기 위해 삽입되는 큐 (상호배제를 위한 큐)와 wait 가 호출되어 실행이 중단된 프로세스들이 삽입되는 대기 큐(조건 변수에 대한 큐)는 서로 다른 큐이다.
전자는 모니터에 진입하기 전에 대기하는 큐 / 후자는 모니터에 이미 진입한 프로세스가 조건이 만족될 때까지 대기하기 위해 만들어진 큐.
```

x.wait() 를 통해 조건변수 x에 대한 wait를 호출 → 조건 변수 x에 대한 큐에 프로세스 삽입 (모니터 빔) → 다른 프로세스 모니터 진입 → 다른 프로세스의 signal 연산을 통해 실행 재개

```
signal
x.signal()를 통해 조건 변수 x에 대한 signal 호출 시, 조건 변수 x에 대한 큐에서 대기하고 있던 프로세스가 모니터로 진입할 수 있게 된다.
```

1) 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행 중단.
2) 특정프로세스가 실행될 조건이 충족되었을 때는 signal을 통해 실행을 재개.
